"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[865],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(n),h=a,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||i;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},71599:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const i={sidebar_position:1},o="Actor Model",s={unversionedId:"understand-vast/architecture/actor-model",id:"understand-vast/architecture/actor-model",title:"Actor Model",description:"VAST uses the actor model to structure control flow",source:"@site/docs/understand-vast/architecture/actor-model.md",sourceDirName:"understand-vast/architecture",slug:"/understand-vast/architecture/actor-model",permalink:"/docs/understand-vast/architecture/actor-model",draft:!1,editUrl:"https://github.com/tenzir/vast/tree/master/web/docs/understand-vast/architecture/actor-model.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"Design Goals",permalink:"/docs/understand-vast/architecture/design-goals"},next:{title:"Components",permalink:"/docs/understand-vast/architecture/components"}},c={},l=[{value:"Execution Model",id:"execution-model",level:2},{value:"C++ Actor Framework (CAF)",id:"c-actor-framework-caf",level:2},{value:"Efficient Message Passing",id:"efficient-message-passing",level:3},{value:"Flexible Distribution",id:"flexible-distribution",level:3},{value:"Actor Scheduling",id:"actor-scheduling",level:3}],d={toc:l};function u(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"actor-model"},"Actor Model"),(0,a.kt)("p",null,"VAST uses the ",(0,a.kt)("a",{parentName:"p",href:"http://dist-prog-book.com/chapter/3/message-passing.html#why-the-actor-model"},"actor model")," to structure control flow\ninto individual components. The actor runtime maps the application logic onto\nOS processes or remote actors in the network. The actor model simplifies the\ndesign a distributed system because it allows for easier reasoning about\nbehavior, while providing a light-weight concurrency primitive that scales\nremarkably well, both within a single machine as well as in a distributed\ncluster."),(0,a.kt)("h2",{id:"execution-model"},"Execution Model"),(0,a.kt)("p",null,"An actor defines a sequential unit of processing, while all actors conceptually\nrun in parallel. Because actors solely communicate via message passing, data\nraces do not occur by design. As long as the application exhibits enough\n",(0,a.kt)("em",{parentName:"p"},"overdecomposition"),' (i.e., distinct running actors), there exists enough "work"\nthat the actor runtime can schedule on OS-level threads. The figure below\nillustrates the separation of application logic, actor runtime, and underlying\nhardware. The programmer only thinks in actors (circles), and sending messages\nbetween (arrows), whereas the runtime takes care of scheduling the actor\nexecution.'),(0,a.kt)("div",{align:"center"},(0,a.kt)("img",{src:n(43389).Z,width:"500"})),(0,a.kt)("h2",{id:"c-actor-framework-caf"},"C++ Actor Framework (CAF)"),(0,a.kt)("p",null,"VAST is written in C++. We ",(0,a.kt)("a",{parentName:"p",href:"http://matthias.vallentin.net/papers/thesis-phd.pdf"},"evaluated multiple actor model library\nimplementations")," and\nfound that the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/actor-framework/actor-framework"},"C++ Actor Framework (CAF)")," best suits our needs because of\nthe following unique features:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Efficient copy-on-write message passing"),(0,a.kt)("li",{parentName:"ol"},"A configurable and exchangeable scheduler"),(0,a.kt)("li",{parentName:"ol"},"Typed actor interfaces for compile-time message contract checking")),(0,a.kt)("h3",{id:"efficient-message-passing"},"Efficient Message Passing"),(0,a.kt)("p",null,"CAF's actor runtime transparently serializes messages when they cross process\nboundaries; within a single process all actors send messages via efficient\npointer passing. The figure below illustrates this concept:"),(0,a.kt)("div",{align:"center"},(0,a.kt)("img",{src:n(86187).Z,width:"600"})),(0,a.kt)("p",null,"The main benefit of this capability is deployment flexibility: CAF decides when\nto choose pointer passing and when serialization, based on whether an actor\nruns remotely or within the same process. Without changing a single line of\ncode, we can create different wirings of components while retaining maximum\nefficiency."),(0,a.kt)("h3",{id:"flexible-distribution"},"Flexible Distribution"),(0,a.kt)("p",null,"Letting the runtime transparently manage the messaging yields a highly flexible\ndistribution model. We can either bundle up all actors in a single process\n(centralized) or scale out individual components into own processes\n(distributed). Examples for these two modes include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Centralized"),": network appliance, embedded device at the edge, vertically\nscaled many-core machine"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Distributed"),": cloud functions, auto-scaling container environments (e.g.,\nKubernetes), multi-node data-center clusters")),(0,a.kt)("p",null,"You can think of two ends of the spectrum as follows:"),(0,a.kt)("div",{align:"center"},(0,a.kt)("img",{src:n(25143).Z,width:"500"})),(0,a.kt)("h3",{id:"actor-scheduling"},"Actor Scheduling"),(0,a.kt)("p",null,"By default, CAF uses a\n",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Work_stealing"},"work-stealing")," scheduler to map\nactors to threads. The idea is that there exist as many threads as available\nCPU cores, but orders of magnitude more actors than threads. This results in a\nsteady flow of work, proportional to the amount of communication between the\nactors. The figure below shows the scheduler in action."),(0,a.kt)("div",{align:"center"},(0,a.kt)("img",{src:n(97512).Z,width:"350"})),(0,a.kt)("p",null,'CAF maintains a thread pool, in which every thread maintains its own queue of\n"work," i.e., dispatching control flow into an actor. If an actor sends a\nmessage to another actor, CAF schedules the recipient. Based on how the worker\nthreads plow through their work, there may be scenario where a thread runs out\nof work and ends up with an empty queue. In this case, ',(0,a.kt)("em",{parentName:"p"},"stealing")," kicks in. The\nidle worker (",(0,a.kt)("em",{parentName:"p"},"thief"),") picks an actor from the queue of another thread\n(",(0,a.kt)("em",{parentName:"p"},"victim"),") so that all threads keep churning away. This works very efficiently,\nassuming that stealing is a rare event."))}u.isMDXComponent=!0},43389:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/actor-model-architecture-6b4693824a38d20f46a31d882462ef25.png"},25143:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/actor-model-distribution-14f8384ec43cb3d6a11ae3761c1a91e3.png"},86187:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/actor-model-messaging-7dd62cb25a2fe59a588fb7ce2f50ea11.png"},97512:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/actor-model-workstealing-a1952f420e073d172abfff2b4b221c4e.png"}}]);