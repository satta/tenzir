"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7029],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>c});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(n),c=i,f=d["".concat(l,".").concat(c)]||d[c]||u[c]||r;return n?a.createElement(f,o(o({ref:t},m),{},{components:n})):a.createElement(f,o({ref:t},m))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},77274:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={},o="Sigma",s={unversionedId:"understand-vast/query-language/frontends/sigma",id:"understand-vast/query-language/frontends/sigma",title:"Sigma",description:"The Sigma query frontend makes it possible to execute [Sigma",source:"@site/docs/understand-vast/query-language/frontends/sigma.md",sourceDirName:"understand-vast/query-language/frontends",slug:"/understand-vast/query-language/frontends/sigma",permalink:"/docs/understand-vast/query-language/frontends/sigma",draft:!1,editUrl:"https://github.com/tenzir/vast/tree/master/web/docs/understand-vast/query-language/frontends/sigma.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Frontends",permalink:"/docs/understand-vast/query-language/frontends/"},next:{title:"Develop VAST",permalink:"/docs/develop-vast/"}},l={},p=[{value:"Usage",id:"usage",level:2},{value:"Search Identifiers",id:"search-identifiers",level:3},{value:"Taxonomy",id:"taxonomy",level:3},{value:"Comparison",id:"comparison",level:2},{value:"Expressiveness",id:"expressiveness",level:3},{value:"Compatibility",id:"compatibility",level:2},{value:"Focus on Endpoint",id:"focus-on-endpoint",level:3}],m={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"sigma"},"Sigma"),(0,i.kt)("p",null,"The Sigma query frontend makes it possible to execute ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/SigmaHQ/sigma"},"Sigma\nrules")," in VAST. This means you can\nprovide a Sigma rule instead of a VASTQL expression when querying data. For\nexample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"vast export json < sigma-rule.yaml\n")),(0,i.kt)("p",null,"Sigma defines a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/SigmaHQ/sigma/wiki/Specification"},"YAML-based rule language")," along with a compiler\nthat transforms rules into the native query languages of SIEM systems. The\nrepository also ships with collection of detection rules that apply to endpoint\nand network log telemetry."),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("p",null,"To use the Sigma frontend, ",(0,i.kt)("a",{parentName:"p",href:"/docs/setup-vast/configure#plugins"},"install the ",(0,i.kt)("inlineCode",{parentName:"a"},"sigma"),"\nplugin"),". Then use the ",(0,i.kt)("inlineCode",{parentName:"p"},"vast export")," command\nto provide a Sigma rule on standard input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"vast export <format> < sigma-rule.yaml\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"<format>")," placeholder represents an output format, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"json")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"csv"),",\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"sigma-rule.yaml")," a file containing a Sigma rule."),(0,i.kt)("h3",{id:"search-identifiers"},"Search Identifiers"),(0,i.kt)("p",null,"The Sigma rule YAML format requires a ",(0,i.kt)("inlineCode",{parentName:"p"},"detection")," attribute that includes a map\nof named sub-expression called ",(0,i.kt)("em",{parentName:"p"},"search identifiers"),". In addition, ",(0,i.kt)("inlineCode",{parentName:"p"},"detection"),"\nmust include a final ",(0,i.kt)("inlineCode",{parentName:"p"},"condition")," that combines search identifiers using boolean\nalgebra (AND, OR, and NOT) or syntactic sugar to reference groups of search\nexpressions, e.g., using the ",(0,i.kt)("inlineCode",{parentName:"p"},"1/all of *")," or plain wildcard syntax."),(0,i.kt)("p",null,"Consider the following Sigma ",(0,i.kt)("inlineCode",{parentName:"p"},"detection")," embedded in a rule:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'detection:\n  foo:\n    a: 42\n    b: "evil"\n  bar:\n    c: 1.2.3.4\n  condition: foo or not bar\n')),(0,i.kt)("p",null,"VAST translates this rule piece by building a symbol table of all keys (",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),"). Each sub-expression is a valid VAST expression itself:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"foo"),": ",(0,i.kt)("inlineCode",{parentName:"li"},'a == 42 && b == "evil"')),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"bar"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"c == 1.2.3.4"))),(0,i.kt)("p",null,"Finally, VAST combines the expression according to the ",(0,i.kt)("inlineCode",{parentName:"p"},"condition"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'(a == 42 && b == "evil") || ! (c == 1.2.3.4)\n')),(0,i.kt)("admonition",{title:"Rich YAML Typing",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Because VAST has a beefed up YAML parser that performs type inference, the YAML\nsnippet ",(0,i.kt)("inlineCode",{parentName:"p"},"c: 1.2.3.4")," is parsed as a key-value pair with types ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". This means that we get the rich type system of VAST for free.")),(0,i.kt)("h3",{id:"taxonomy"},"Taxonomy"),(0,i.kt)("p",null,"Sigma comes with a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/SigmaHQ/sigma/wiki/Taxonomy"},"taxonomy")," to\nfacilitate rule sharing by standardizing field names of the supported data\nsources."),(0,i.kt)("admonition",{title:"Missing Definitions",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"VAST currently does not ship with a taxonomy to transparently map the canonical\nSigma fields to an equivalent in VAST. We will ship the missing mappings in the\nfuture. To date, you must either use VAST concepts to re-implement the mappings\nor wait until we have provided them.")),(0,i.kt)("h2",{id:"comparison"},"Comparison"),(0,i.kt)("p",null,"VAST and Sigma have many commonalities. They both support flexible construction\nof search expressions using boolean algebra (AND, OR, NOT) and offer multiple\nways to define predicates and sub-expression. But there also exist differences\nin expressiveness and intent. This section compares the two systems."),(0,i.kt)("h3",{id:"expressiveness"},"Expressiveness"),(0,i.kt)("p",null,"The majority of rule definitions include combinations of exact string lookups,\nsubstring searches, or pattern matches. Sigma uses\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/SigmaHQ/sigma/wiki/Specification#value-modifiers"},"modifiers"),"\nto select a concrete operator for given search predicate. Without a modifier\nspecification, Sigma uses equality comparison (",(0,i.kt)("inlineCode",{parentName:"p"},"=="),") of field and value. For\nexample, the ",(0,i.kt)("inlineCode",{parentName:"p"},"contains")," modifier changes the operator to substring search, and\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"re")," modifier switches to a regular expression match."),(0,i.kt)("p",null,"Sigma currently lacks support for ordering relationships, such as less-than\ncomparison of numerical values, e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"x < 42")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"timestamp >= 2021-02"),",\nwhereas VAST offers relational operators (",(0,i.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,i.kt)("inlineCode",{parentName:"p"},">="),", ",(0,i.kt)("inlineCode",{parentName:"p"},">"),") for numeric\ntypes."),(0,i.kt)("h2",{id:"compatibility"},"Compatibility"),(0,i.kt)("p",null,"VAST's support for Sigma is still in the early stages and does not support the\nfull ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/SigmaHQ/sigma/wiki/Specification"},"language specification"),". The following features are currently\nunsupported:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Certain value invariants:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"VAST does not offer case-insensitive search, whereas it's the default in\nSigma"),(0,i.kt)("li",{parentName:"ul"},"Interpretation of string values containing ",(0,i.kt)("inlineCode",{parentName:"li"},"*")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"?")," wildcards  "))),(0,i.kt)("li",{parentName:"ul"},"The following modifiers:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"re")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"base64")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"base64offset")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"utf16le")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"wide")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"utf16be")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"utf16")))),(0,i.kt)("li",{parentName:"ul"},"TimeFrame specification"),(0,i.kt)("li",{parentName:"ul"},"Aggregation expressions"),(0,i.kt)("li",{parentName:"ul"},"Near aggregation expressions")),(0,i.kt)("h3",{id:"focus-on-endpoint"},"Focus on Endpoint"),(0,i.kt)("p",null,"Sigma predominantly offers rules with a focus on endpoint data, such as\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon"},"Sysmon"),"\ntelemetry. While there exist rules for network-based detections (e.g., for\nDNS queries, SMB events, and Kerberos traffic), they receive less attention."),(0,i.kt)("p",null,"As of June 2022, the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/SigmaHQ/sigma/tree/d78818e27d42710f427eb205a9ca59b4ab97e728/rules"},"rules")," directory includes a total of\n2,015 total ",(0,i.kt)("inlineCode",{parentName:"p"},"*.yml")," files compared to 51 files in the ",(0,i.kt)("inlineCode",{parentName:"p"},"network")," directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"find rules -name '*.yml' | wc -l\n2015\nfind rules/network -name '*.yml' | wc -l\n51\n")),(0,i.kt)("p",null,"That is, network-based rules account only for ",(0,i.kt)("strong",{parentName:"p"},"2.5%")," of the total rules. This\nillustrates the emphasis of the community and project authors, who have strong\nbackground in endpoint detection."),(0,i.kt)("p",null,"VAST's history emphasizes network telemetry, with native support for PCAP,\nNetFlow, and full support for network monitors like Zeek and Suricata. By\nnatively supporting Sigma in VAST, we are looking forward to offer a platform\nwith detection capabilities on both ends of the spectrum."))}u.isMDXComponent=!0}}]);